#!/usr/bin/env python3

#Builds a feat database from the LaTeX files and saves it in JSON format.
#Takes two or more command line arguments.
#Firstly, the path of the JSON file to output to.
#Subsequently, the paths of one or more LaTeX files to read feats from.

#If a feat does not provide the optional argument to specify its discipline,
#the discipline is taken from the file name.
#TODO: Invent a better method than this.

#A feat's prereqs are stored using a recursive tree structure.
#Each node of the tree is a dictionary, in python parlance (an object in JSON parlance).
#Every node has an entry with the key "type", that defines what type of node it is.
#The various types, and the other entries they will have, are given below.
#"list":
#	A list of prerequisite nodes, all of which must be satisfied.
#	Represented in the book as an ordered, comma-separated list.
#	Has one entry: "nodes", an array of nodes.
#"and":
#	Mechanically identically to a "list", and similarly just has one "noes" entry.
#	Differs in that it is separated in the book with the word 'and' instead of commas.
#	This is just used occasionally for emphasis (see \featref{circle-contain-exclude}).
#"or":
#	A list of prerequisite nodes, any one of which must be satisfied.
#	Represented in the book as a list separated with the word 'or'.
#	Has one entry: "nodes", an array of nodes.
#"feat":
#	A feat.
#	Has one entry: "label", a string with the label of the required feat.
#"anyfeat":
#	A signifier that you must have any one feat from a particular discipline.
#	Has one entry: "discipline", a string with the discipline you must have a feat from.
#"skill":
#	A general or discipline skill.
#	Has two entries: "label" and "level".
#	"label" is a string containing the label of the required skill.
#	"level" is an integer; the minimum level at which the skill is required.
#"specialityskill":
#	A speciality skill.
#	Has the same two "label" and "level" entires as above, plus a "speciality" level.
#	"speciality" is a string containing the speciality you must have.
#	"speciality" is allowed to take a None value (null in JSON parlance).
#	A null "speciality" signifies that any speciality of that skill will suffice.
#"familiar":
#	A type of familiar you must have.
#	Has one entry: "label", the label of the familiar you must have.
#	TODO: This will inevitably need to expand as familiar prereqs grow more complicated.
#"familiarskill" and "specialityskillfamiliar"
#	As "skill" and "specialityskill", but representing a skill the familiar must have.

#TODO: There needs to be some marker that a feat can be taken more than once.
#This will be needed for the feats that improve familiars' attributes/skills.
#Further, those feats (and the druidcraft animal training feats) will have to have their effect encoded.
#This will allow the character creator to display the familiar's modified stats, and use them as prereqs.

import sys
import os
import json
from pylatexenc.macrospec import MacroSpec, MacroStandardArgsParser, LatexContextDb
from pylatexenc.latexwalker import get_default_latex_context_db
from pylatexenc.latexwalker import LatexWalker, LatexMacroNode, LatexGroupNode

def print_usage(argv):
	print("Usage: {} output-file input-file [input-file]...".format(argv[0]), file = sys.stderr)

def get_latex_context():
	#LatexWalker needs a context in which all macros are defined.
	#Here, we build the context, with the \feat macro defined.
	context = get_default_latex_context_db()
	
	context.add_context_category("coven", macros=[
		MacroSpec("feat", MacroStandardArgsParser("[{{{{{")),
	])
	
	return context

def expand_argument(argument_node):
	#Takes a LatexNode that represents an argument to a macro, and expands it out of a LatexGroupNode if it is one.
	#Returns a list of LatexNodes.
	node_list = []
	
	#If the argument is a group, take all the nodes from the group.
	#Otherwise, just the node itself.
	if(argument_node.isNodeType(LatexGroupNode)):
		node_list = argument_node.nodelist
	else:
		node_list = [node]
	
	return node_list

def argument_as_string(argument_node):
	#Takes a LatexNode that represents an argument to a macro, and returns the text therein.
	#This is the raw text, without parsing any LaTeX within.
	node_list = expand_argument(argument_node)
	
	#Take the relevant sections from the LatexWalker's string.
	node_texts = [node.parsing_state.s[node.pos : node.pos + node.len] for node in node_list]
	return ''.join(node_texts)

def get_feat(feat_node, default_discipline):
	#Takes a LatexMacroNode with macroname "feat" and returns a dictionary that represents the feat.
	#The feat is returned as a dictionary, instead of as a class, so that it converts to JSON.
	feat = {}
	
	argument_nodes = feat_node.nodeargd.argnlist
	
	feat["discipline"] = argument_as_string(argument_nodes[0]) if argument_nodes[0] else default_discipline
	feat["name"] = argument_as_string(argument_nodes[1])
	feat["label"] = argument_as_string(argument_nodes[2])
	feat["cost"] = int(argument_as_string(argument_nodes[3]))
	feat["prereqs"] = argument_as_string(argument_nodes[4]) #TODO: Process the prerequisites.
	feat["content"] = argument_as_string(argument_nodes[5]) #TODO: Convert the LaTeX contents to HTML markup.
	
	return feat

def get_feats(file_path):
	#Takes a file path, and returns an array of feats.
	file = open(file_path, "r")
	walker = LatexWalker(file.read(), latex_context = get_latex_context())
	file.close()
	
	default_discipline = os.path.basename(file_path).removesuffix(".tex")
	
	(nodelist, _, _) = walker.get_latex_nodes()
	feats = [get_feat(node, default_discipline) for node in nodelist if node.isNodeType(LatexMacroNode) and node.macroname == "feat"]
	return feats

def main(argv):
	if(len(argv) < 3):
		print_usage(argv)
		sys.exit(1)
	
	outfile_path = argv[1]
	infile_paths = argv[2:]
	
	feats = []
	for infile_path in infile_paths:
		feats.extend(get_feats(infile_path))
	
	outfile = open(outfile_path, "w")
	print(json.dumps(feats), file = outfile)
	outfile.close()

main(sys.argv)
