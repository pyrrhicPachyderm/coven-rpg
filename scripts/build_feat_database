#!/usr/bin/env python3

#Builds a feat database from the LaTeX files and saves it in JSON format.
#Takes two or more command line arguments.
#Firstly, the path of the JSON file to output to.
#Subsequently, the paths of one or more LaTeX files to read feats from.

#A feat's prereqs are stored using a recursive tree structure.
#Each node of the tree is a dictionary, in python parlance (an object in JSON parlance).
#Every node has an entry with the key "type", that defines what type of node it is.
#The various types, and the other entries they will have, are given below.
#"list":
#	A list of prerequisite nodes, all of which must be satisfied.
#	Represented in the book as an ordered, comma-separated list.
#	Has one entry: "nodes", an array of nodes.
#"and":
#	Mechanically identically to a "list", and similarly just has one "nodes" entry.
#	Differs in that it is separated in the book with the word 'and' instead of commas.
#	This is just used occasionally for emphasis (see \featref{circle-contain-exclude}).
#"or":
#	A list of prerequisite nodes, any one of which must be satisfied.
#	Represented in the book as a list separated with the word 'or'.
#	Has one entry: "nodes", an array of nodes.
#"feat":
#	A feat.
#	Has one entry: "label", a string with the label of the required feat.
#"anyfeatdiscipline":
#	A signifier that you must have any one feat from a particular discipline.
#	Has one entry: "discipline", a string with the discipline you must have a feat from.
#"Anyfeatdiscipline":
#	As "anyfeatdiscipline", but indicating that the text should be capitalised.
#"anyfeatmaterial":
#	A signifier that you must have any one feat that uses a particular material.
#	Has two entries: "material" and "article"
#	"material" is a string with the label of the relevant material.
#	"article" is a string giving the appropriate article for the material, such as "a" or "an".
#"Anyfeatmaterial":
#	As "anyfeatmaterial", but indicating that the text should be capitalised.
#"skill":
#	A general or discipline skill.
#	Has two entries: "label" and "level".
#	"label" is a string containing the label of the required skill.
#	"level" is an integer; the minimum level at which the skill is required.
#"specialityskill":
#	A speciality skill.
#	Has the same two "label" and "level" entires as above, plus a "speciality" level.
#	"speciality" is a string containing the speciality you must have.
#	"speciality" is allowed to take a None value (null in JSON parlance).
#	A null "speciality" signifies that any speciality of that skill will suffice.
#"familiar":
#	A type of familiar you must have.
#	Has one entry: "label", the label of the familiar you must have.
#	TODO: This will inevitably need to expand as familiar prereqs grow more complicated.
#"familiarskill" and "specialityskillfamiliar"
#	As "skill" and "specialityskill", but representing a skill the familiar must have.

#TODO: There needs to be some marker that a feat can be taken more than once.
#This will be needed for the feats that improve familiars' attributes/skills.
#Further, those feats (and the druidcraft animal training feats) will have to have their effect encoded.
#This will allow the character creator to display the familiar's modified stats, and use them as prereqs.

import sys
import os
import json
import re
from pylatexenc.macrospec import MacroSpec, MacroStandardArgsParser, LatexContextDb
from pylatexenc.latexwalker import get_default_latex_context_db
from pylatexenc.latexwalker import LatexWalker, LatexMacroNode, LatexGroupNode, LatexCharsNode, LatexCommentNode

class ParsingError(Exception):
	pass

def print_usage(argv):
	print("Usage: {} output-file input-file [input-file]...".format(argv[0]), file = sys.stderr)

def print_error(error_message):
	print(error_message, file = sys.stderr)

def get_latex_context():
	#LatexWalker needs a context in which all macros are defined.
	#Here, we build the context, with the \feat macro defined.
	context = get_default_latex_context_db()
	
	context.add_context_category("coven", macros=[
		MacroSpec("feat", MacroStandardArgsParser("{{[{[{{")),
		
		MacroSpec("featref", MacroStandardArgsParser("{")),
		MacroSpec("skillref", MacroStandardArgsParser("[{")),
		MacroSpec("skillrefspeciality", MacroStandardArgsParser("[{{")),
		MacroSpec("skillreffamiliar", MacroStandardArgsParser("[{")),
		MacroSpec("anyfeatdiscipline", MacroStandardArgsParser("{")),
		MacroSpec("Anyfeatdiscipline", MacroStandardArgsParser("{")),
		MacroSpec("anyfeatmaterial", MacroStandardArgsParser("[{")),
		MacroSpec("Anyfeatmaterial", MacroStandardArgsParser("[{")),
		MacroSpec("prereqfamiliar", MacroStandardArgsParser("{")),
		MacroSpec("noprereq", MacroStandardArgsParser("")),
		
		MacroSpec("setfeatdefault", MacroStandardArgsParser("{{{")),
		MacroSpec("unsetfeatdefault", MacroStandardArgsParser("{")),
		
		MacroSpec("dice", MacroStandardArgsParser("[{")),
		MacroSpec("testtype", MacroStandardArgsParser("{{")),
		MacroSpec("testtypespeciality", MacroStandardArgsParser("{{")),
		
		MacroSpec("capital", MacroStandardArgsParser("{")),
	])
	
	return context

def expand_argument(argument_node):
	#Takes a LatexNode that represents an argument to a macro, and expands it out of a LatexGroupNode if it is one.
	#Returns a list of LatexNodes.
	node_list = []
	
	#If the argument is a group, take all the nodes from the group.
	#Otherwise, just the node itself.
	if argument_node.isNodeType(LatexGroupNode):
		node_list = argument_node.nodelist
	else:
		node_list = [node]
	
	return node_list

def argument_as_string(argument_node):
	#Takes a LatexNode that represents an argument to a macro, and returns the text therein.
	#This is the raw text, without parsing any LaTeX within.
	node_list = expand_argument(argument_node)
	
	#Take the relevant sections from the LatexWalker's string.
	node_texts = [node.parsing_state.s[node.pos : node.pos + node.len] for node in node_list]
	return ''.join(node_texts)

def parse_prereq_argument_text(argument_node):
	return argument_as_string(argument_node)

def parse_prereq_argument_integer(argument_node):
	text = argument_as_string(argument_node)
	try:
		return int(text)
	except ValueError:
		raise ParsingError #Could not convert text to integer.

def parse_prereq_argument_skill_speciality(argument_node):
	if any([node.isNodeType(LatexMacroNode) and node.macroname == "anyspeciality" for node in expand_argument(argument_node)]):
		return None
	else:
		return argument_as_string(argument_node)

#Dictionary mapping macronames to prereq node types they create.
#Also shows the arguments of each macro, and the functions to process them.
PREREQ_MACRO_DEFINITIONS = {
	"featref": ("feat", [
		("label", parse_prereq_argument_text),
	]),
	"anyfeatdiscipline": ("anyfeatdiscipline", [
		("discipline", parse_prereq_argument_text),
	]),
	"Anyfeatdiscipline": ("Anyfeatdiscipline", [
		("discipline", parse_prereq_argument_text),
	]),
	"anyfeatmaterial": ("anyfeatmaterial", [
		("article", parse_prereq_argument_text),
		("material", parse_prereq_argument_text),
	]),
	"Anyfeatmaterial": ("Anyfeatmaterial", [
		("article", parse_prereq_argument_text),
		("material", parse_prereq_argument_text),
	]),
	"skillref": ("skill", [
		("level", parse_prereq_argument_integer),
		("label", parse_prereq_argument_text),
	]),
	"skillrefspeciality": ("specialityskill", [
		("level", parse_prereq_argument_integer),
		("label", parse_prereq_argument_text),
		("speciality", parse_prereq_argument_skill_speciality),
	]),
	"skillreffamiliar": ("familiarskill", [
		("level", parse_prereq_argument_integer),
		("label", parse_prereq_argument_text),
	]),
	"prereqfamiliar": ("familiar", [
		("label", parse_prereq_argument_text),
	]),
}

#Dictionary mapping separator to the prereq node type it creates.
PREREQ_SEPARATOR_DEFINITIONS = {
	",": "list",
	"and": "and",
	"or": "or",
}

#Array of separators from highest to lowest precendence.
PREREQ_SEPARATOR_PRECEDENCE = [
	"and",
	"or",
	",",
]

def parse_prereq_macro(macro_node):
	#Takes a LatexMacroNode that represents a macro within a feat's prerequisites.
	#Returns a prerequisite dictionary, with the format as specified at the top of the document.
	#Handles only terminal nodes of the prerequisites tree (e.g. feats, skills).
	#Lists, "and"s and "or"s are handled by get_prereqs() itself.
	
	if macro_node.macroname == "noprereq":
		return None
	
	prereq = {}
	
	try:
		prereq["type"], argument_definitions = PREREQ_MACRO_DEFINITIONS[macro_node.macroname]
	except KeyError:
		raise ParsingError #macroname is not valid.
	
	argument_nodes = macro_node.nodeargd.argnlist
	
	if len(argument_nodes) != len(argument_definitions):
		raise ParsingError #Arguments do not match definitions.
	
	for index, argument_node in enumerate(argument_nodes):
		argument_name, argument_parser = argument_definitions[index]
		prereq[argument_name] = argument_parser(argument_node)
	
	return prereq

def get_prereqs(argument_node):
	#Takes a LatexNode that represents the relevant argument to \feat.
	#Returns a prerequisites dictionary, with the format as specified at the top of the document.
	
	#We take all the nodes that form the prereqs argument, remove comments, and remove text that is only whitespace.
	#This should reduce the list to an alternating list of macros and separators.
	#Macros are LatexMacroNodes and separators are LatexCharsNodes.
	#The separators, after removing whitespace, should be ",", "and" or "or".
	
	node_list = expand_argument(argument_node) #TODO: Make this recursive, to expand groups within.
	node_list = [node for node in node_list if not (
		node.isNodeType(LatexCommentNode) or
		(node.isNodeType(LatexCharsNode) and re.match(r"^\s*$", node.chars))
	)] #Discard comments and whitespace-only nodes.
	
	#There should now be an odd number of nodes.
	#Every even-indexed node should be a macro. Every odd-indexed one should be text.
	#Throw a parsing error if this is not the case.
	#TODO: Make these errors more informative.
	
	if len(node_list)%2 != 1:
		raise ParsingError
	
	macro_node_list = [node for index, node in enumerate(node_list) if index%2 == 0]
	separator_node_list = [node for index, node in enumerate(node_list) if index%2 == 1]
	if not all([node.isNodeType(LatexMacroNode) for node in macro_node_list]):
		raise ParsingError
	if not all([node.isNodeType(LatexCharsNode) for node in separator_node_list]):
		raise ParsingError
	
	#Parse the macros into their appropriate dictionaries, and the separators into raw text.
	#Remove any whitespace from the separators.
	prereq_list = [parse_prereq_macro(node) for node in macro_node_list]
	separator_list = [re.sub("\s", "", node.chars) for node in separator_node_list]
	
	#Check that all the separators are valid.
	if any([separator not in PREREQ_SEPARATOR_PRECEDENCE for separator in separator_list]):
		raise ParsingError #Invalid separators.
	
	#Iterate over each type of separator, in precendence order.
	#For each separator, collapse the prereqs into groups based on the separator.
	for separator in PREREQ_SEPARATOR_PRECEDENCE:
		group_type = PREREQ_SEPARATOR_DEFINITIONS[separator]
		i = 0
		while i < len(separator_list):
			#Is this the type of separator we're dealing with right now?
			if separator_list[i] == separator:
				#Do we already have the correct type of group to collapse this into?
				#If not, create it.
				if not prereq_list[i]["type"] == group_type:
					prereq_list[i] = {
						"type": group_type,
						"nodes": [prereq_list[i]],
					}
				#Collapse the next prereq into this group.
				prereq_list[i]["nodes"].append(prereq_list.pop(i+1))
				#Delete the separator, now that it's parsed.
				separator_list.pop(i)
				#Do not increment i. len(separator_list) has decremented.
			else:
				i += 1
	
	#All the prereqs should have collapsed to just one now; check this has occurred.
	if len(prereq_list) != 1:
		raise ParsingError #Prereq list has not fully collapsed.
	
	return prereq_list[0]

def get_feat(feat_node, defaults):
	#Takes a LatexMacroNode with macroname "feat" and returns a dictionary that represents the feat.
	#The feat is returned as a dictionary, instead of as a class, so that it converts to JSON.
	feat = {}
	
	argument_nodes = feat_node.nodeargd.argnlist
	
	feat["name"] = argument_as_string(argument_nodes[0])
	feat["label"] = argument_as_string(argument_nodes[1])
	feat["discipline"] = argument_as_string(argument_nodes[2]) if argument_nodes[2] else None
	feat["cost"] = int(argument_as_string(argument_nodes[3]))
	feat["tags"] = argument_as_string(argument_nodes[4]) if argument_nodes[4] else None #TODO: Parse tags into list.
	try:
		feat["prereqs"] = get_prereqs(argument_nodes[5])
	except ParsingError:
		print_error("Failed to parse the prerequisites for {}".format(feat["label"]))
		sys.exit(2)
	feat["content"] = argument_as_string(argument_nodes[6]) #TODO: Convert the LaTeX contents to HTML markup.
	
	#Use the defaults for missing arguments.
	for key in feat:
		if feat[key] == None:
			try:
				feat[key] = defaults[key]
			except KeyError:
				pass #Leave the entry as None.
	
	#TODO: Set feat["tier"]; the level of the discipline skill the feat requires.
	
	return feat

DEFAULT_DEFAULTS = {
	"discipline": None,
	"tags": None,
}

def update_defaults(defaults, macro_node):
	#Takes a defaults dictionary and a LatexMacroNode representing either \setfeatdefault or \unsetfeatdefault.
	#Returns the updated defaults dictionary.
	#A defaults dictionary is the same as a feat dictionary, but only with entries that represent optional arguments.
	#It stores the default value for each optional argument.
	#Currently ignoring the third argument of \setfeatdefault; the character creator doesn't care about discipline/tag visibility.
	argument_nodes = macro_node.nodeargd.argnlist
	key = argument_as_string(argument_nodes[0])
	value = argument_as_string(argument_nodes[1]) if macro_node.macroname == "setfeatdefault" else None
	defaults[key] = value
	
	return defaults

def get_feats(file_path):
	#Takes a file path, and returns an array of feats.
	file = open(file_path, "r")
	walker = LatexWalker(file.read(), latex_context = get_latex_context())
	file.close()
	
	defaults = DEFAULT_DEFAULTS
	feats = []
	
	(node_list, _, _) = walker.get_latex_nodes()
	for node in [node for node in node_list if node.isNodeType(LatexMacroNode)]:
		if node.macroname == "feat":
			feats.append(get_feat(node, defaults))
		elif node.macroname in ["setfeatdefault", "unsetfeatdefault"]:
			defaults = update_defaults(defaults, node)
		else:
			pass
	
	return feats

def main(argv):
	if len(argv) < 3:
		print_usage(argv)
		sys.exit(1)
	
	outfile_path = argv[1]
	infile_paths = argv[2:]
	
	feats = []
	for infile_path in infile_paths:
		feats.extend(get_feats(infile_path))
	
	outfile = open(outfile_path, "w")
	print(json.dumps(feats), file = outfile)
	outfile.close()

main(sys.argv)
